/* Copyright 2010-2011 10gen Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

var fs = require('fs');
var util = require('util');
var path = require('path');
var EventEmitter = require('events').EventEmitter;


function getJsonFile(roleName, endpointName, callback) {
  var jsonFile = path.join('azureMongoEndpoints', roleName, endpointName + '.json');

  if (process.env.ROLEROOT) {
    jsonFile = path.join(process.env.ROLEROOT, 'approot', jsonFile);
    callback(jsonFile);
  } else {
    path.exists(jsonFile, function (exists) {
      if (!exists) {
        // This code path only happens when running IISNode in the emulator.
        // We don't get the %ROLEROOT% env. variable in IIS.  And when running
        // in the emulator, the current directory is not %ROLEROOT%.
        // As a workaround, we assume that we can find %ROLEROOT% in local_package.csx folder.
        var myRoleName = path.basename(process.cwd());
        jsonFile = path.join(process.cwd(),
                             '..',
                             'local_package.csx',
                             'roles',
                             myRoleName,
                             'approot',
                             jsonFile);
      }

      callback(jsonFile);
    });
  }
}


function initialize(self) {
  // Load initial endpoints.
  loadEndpoints(self);

  // Watch for changes
  fs.watch(self._jsonFile, {persistent: false}, function () {
    loadEndpoints(self);
  });

  // Helper to get mongodb server config
  self.getMongoDBServerConfig = function () {
    var MongoServer = require('mongodb').Server;
    var MongoReplSetServers = require('mongodb').ReplSetServers;

    if (self.instances.length == 0) {
      self.emit('error', Error("No servers available."));
    } else if (self.instances.length == 1) {
      return new MongoServer(self.instances[0].host, self.instances[0].port,
        { auto_reconnect: true });
    } else {
      var servers = [];
      self.instances.forEach(function (endpoint) {
        servers.push(new MongoServer(endpoint.host, endpoint.port,
          { auto_reconnect: true }));
      });

      var options = { rs_name: 'rs'};
      return new MongoReplSetServers(servers, options);
    }
  };
}


function AzureMongoEndpoint(roleName, endpointName) {
  var self = this;
  self.instances = [];
  getJsonFile(roleName, endpointName, function(jsonFile) {
    self._jsonFile = jsonFile;

    path.exists(self._jsonFile, function (exists) {
      if (!exists) {
        self.emit('error', new Error(self._jsonFile + ' does not exist'));
      } else {
        initialize(self);
      }
    });
  });
}
util.inherits(AzureMongoEndpoint, EventEmitter);


module.exports.AzureMongoEndpoint = AzureMongoEndpoint;


function loadEndpoints(self) {
  fs.readFile(self._jsonFile, function (err, data) {
    if (!err) {
      var newInstances = JSON.parse(data).instances.sort();
      var changed = false;

      if (newInstances.length == self.instances.length) {
        // Make sure that we only fire the topologyChange event if something
        // actually changed.
        for (var i = 0; i < newInstances.length; i++) {
          if (newInstances[i].host !== self.instances[i].host ||
              newInstances[i].port !== self.instances[i].port) {
            changed = true;
            break;
          }
        }
      } else {
        changed = true;
      }

      if (changed) {
        self.instances = newInstances;
        self.emit('topologyChange');
      }
    }
  });
}
